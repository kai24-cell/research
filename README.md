# research
#CPU高負荷
stress_cpu
    stressコマンドを使い、指定されたコア数と時間でCPUに負荷をかける。

1. CPUメトリクス 
コンピュータの「頭脳」であるCPUの状態を多角的に調べています。

psutil.cpu_percent(): CPU全体の現在の使用率です。「今、CPUは能力の何%を使っているか」を示します。

psutil.cpu_times_percent(): CPUの時間の使い方の内訳です。

user: アプリケーションなど、ユーザーが直接使っているプログラムの処理に費やした時間。

system: OS自体の管理など、システム内部の処理に費やした時間。

idle: 何もせず待機していた「暇な」時間。

iowait: ディスクの読み書きなどをCPUが待っている時間。

psutil.getloadavg(): ロードアベレージ。CPUがどれだけ「混雑しているか」を示す指標です。「処理待ちのタスクが平均で何件溜まっているか」を表し、システムの負荷状況を判断するのに役立ちます。

2. メモリメトリクス 💾
コンピュータの「作業机」であるメモリの使用状況です。

psutil.virtual_memory(): **物理メモリ（RAM）**の使用率です。

psutil.swap_memory(): スワップ領域の使用率です。物理メモリが足りなくなったときに、ハードディスクの一部をメモリ代わりに使う領域のことで、ここの使用率が高いとPCの動作が遅くなっている可能性があります。

3. ディスク & ネットワークI/Oレート 🔄
ここが少し高度な部分です。ディスクやネットワークは、単に使用量を見るだけでなく**「どれくらいの速さでデータのやり取りが行われているか」というレート（速度）**を計算しています。

psutil.disk_io_counters() や psutil.net_io_counters() が返す値は、PC起動時からの累計データ量です。車の走行距離メーターのようなものですね。

現在の速度を知るには、前回の測定値との差分を取る必要があります。

Python

# 速度 = (現在の走行距離 - 1秒前の走行距離) / 1秒
disk_read_rate = (current_disk_io.read_bytes - self.last_disk_io.read_bytes) / self.interval
この計算で、「1秒あたりの読み込み/書き込みバイト数」といったリアルタイムの通信速度を算出しています。self.last_disk_io に前回の測定値を保存しておくことで、次回の計算に使えるようにしています。

4. プロセス数
len(psutil.pids()): 現在システムで実行されているプロセスの総数です。PC上でいくつのプログラム（バックグラウンドで動くものも含む）が動いているかを示します。